import { SplitIO } from '../../types';
import { IEventsCacheSync } from '../types';
export declare class EventsCacheInMemory implements IEventsCacheSync {
    private onFullQueue?;
    private readonly maxQueue;
    private queue;
    private queueByteSize;
    /**
     *
     * @param eventsQueueSize number of queued events to call onFullQueueCb.
     * Default value is 0, that means no maximum value, in case we want to avoid this being triggered.
     */
    constructor(eventsQueueSize?: number);
    setOnFullQueueCb(cb: () => void): void;
    /**
     * Add a new event object at the end of the queue.
     */
    track(data: SplitIO.EventData, size?: number): boolean;
    /**
     * Clear the data stored on the cache.
     */
    clear(): void;
    /**
     * Pop the collected data, used as payload for posting.
     */
    pop(toMerge?: SplitIO.EventData[]): SplitIO.EventData[];
    /**
     * Check if the cache is empty.
     */
    isEmpty(): boolean;
    /**
     * Check if the cache queue is full and we need to flush it.
     */
    private _checkForFlush;
}
