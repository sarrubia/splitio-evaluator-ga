import { ILogger } from '../../logger/types';
import { Method, MultiConfigs, MultiMethodExceptions, MultiMethodLatencies } from '../../sync/submitters/types';
import { KeyBuilderSS } from '../KeyBuilderSS';
import { IPluggableStorageWrapper, ITelemetryCacheAsync } from '../types';
export declare class TelemetryCachePluggable implements ITelemetryCacheAsync {
    private readonly log;
    private readonly keys;
    private readonly wrapper;
    /**
     * Create a Telemetry cache that uses a storage wrapper.
     * @param log  Logger instance.
     * @param keys  Key builder.
     * @param wrapper  Adapted wrapper storage.
     */
    constructor(log: ILogger, keys: KeyBuilderSS, wrapper: IPluggableStorageWrapper);
    recordLatency(method: Method, latencyMs: number): Promise<number | void>;
    recordException(method: Method): Promise<number | void>;
    recordConfig(): Promise<boolean | void>;
    /**
     * Pop telemetry latencies.
     * The returned promise rejects if wrapper operations fail.
     */
    popLatencies(): Promise<MultiMethodLatencies>;
    /**
     * Pop telemetry exceptions.
     * The returned promise rejects if wrapper operations fail.
     */
    popExceptions(): Promise<MultiMethodExceptions>;
    /**
     * Pop telemetry configs.
     * The returned promise rejects if wrapper operations fail.
     */
    popConfigs(): Promise<MultiConfigs>;
}
