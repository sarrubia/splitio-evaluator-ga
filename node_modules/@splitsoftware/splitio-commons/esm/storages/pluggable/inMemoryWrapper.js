import { startsWith, toNumber } from '../../utils/lang';
import { setToArray, _Set } from '../../utils/lang/sets';
/**
 * Creates a IPluggableStorageWrapper implementation that stores items in memory.
 * The `_cache` property is the object were items are stored.
 * Intended for testing purposes.
 *
 * @param connDelay delay in millis for `connect` resolve. If not provided, `connect` resolves inmediatelly.
 */
export function inMemoryWrapperFactory(connDelay) {
    var _cache = {};
    var _connDelay = connDelay;
    return {
        /** Holds items (for key-value operations), list of items (for list operations) and set of items (for set operations) */
        _cache: _cache,
        get: function (key) {
            return Promise.resolve(key in _cache ? _cache[key] : null);
        },
        set: function (key, value) {
            var result = key in _cache;
            _cache[key] = value;
            return Promise.resolve(result);
        },
        getAndSet: function (key, value) {
            var result = key in _cache ? _cache[key] : null;
            _cache[key] = value;
            return Promise.resolve(result);
        },
        del: function (key) {
            var result = key in _cache;
            delete _cache[key];
            return Promise.resolve(result);
        },
        getKeysByPrefix: function (prefix) {
            return Promise.resolve(Object.keys(_cache).filter(function (key) { return startsWith(key, prefix); }));
        },
        incr: function (key, increment) {
            if (increment === void 0) { increment = 1; }
            if (key in _cache) {
                var count = toNumber(_cache[key]) + increment;
                if (isNaN(count))
                    return Promise.reject('Given key is not a number');
                _cache[key] = count + '';
                return Promise.resolve(count);
            }
            else {
                _cache[key] = '' + increment;
                return Promise.resolve(1);
            }
        },
        decr: function (key, decrement) {
            if (decrement === void 0) { decrement = 1; }
            if (key in _cache) {
                var count = toNumber(_cache[key]) - decrement;
                if (isNaN(count))
                    return Promise.reject('Given key is not a number');
                _cache[key] = count + '';
                return Promise.resolve(count);
            }
            else {
                _cache[key] = '-' + decrement;
                return Promise.resolve(-1);
            }
        },
        getMany: function (keys) {
            return Promise.resolve(keys.map(function (key) { return _cache[key] ? _cache[key] : null; }));
        },
        pushItems: function (key, items) {
            if (!(key in _cache))
                _cache[key] = [];
            var list = _cache[key];
            if (Array.isArray(list)) {
                list.push.apply(list, items);
                return Promise.resolve();
            }
            return Promise.reject('key is not a list');
        },
        popItems: function (key, count) {
            var list = _cache[key];
            return Promise.resolve(Array.isArray(list) ? list.splice(0, count) : []);
        },
        getItemsCount: function (key) {
            var list = _cache[key];
            return Promise.resolve(Array.isArray(list) ? list.length : 0);
        },
        itemContains: function (key, item) {
            var set = _cache[key];
            if (!set)
                return Promise.resolve(false);
            if (set instanceof _Set)
                return Promise.resolve(set.has(item));
            return Promise.reject('key is not a set');
        },
        addItems: function (key, items) {
            if (!(key in _cache))
                _cache[key] = new _Set();
            var set = _cache[key];
            if (set instanceof _Set) {
                items.forEach(function (item) { return set.add(item); });
                return Promise.resolve();
            }
            return Promise.reject('key is not a set');
        },
        removeItems: function (key, items) {
            if (!(key in _cache))
                _cache[key] = new _Set();
            var set = _cache[key];
            if (set instanceof _Set) {
                items.forEach(function (item) { return set.delete(item); });
                return Promise.resolve();
            }
            return Promise.reject('key is not a set');
        },
        getItems: function (key) {
            var set = _cache[key];
            if (!set)
                return Promise.resolve([]);
            if (set instanceof _Set)
                return Promise.resolve(setToArray(set));
            return Promise.reject('key is not a set');
        },
        // always connects and disconnects
        connect: function () {
            if (typeof _connDelay === 'number') {
                return new Promise(function (res) { return setTimeout(res, _connDelay); });
            }
            else {
                return Promise.resolve();
            }
        },
        disconnect: function () { return Promise.resolve(); },
        // for testing
        _setConnDelay: function (connDelay) {
            _connDelay = connDelay;
        }
    };
}
