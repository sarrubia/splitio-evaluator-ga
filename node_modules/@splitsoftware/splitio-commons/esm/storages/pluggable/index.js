import { __assign } from "tslib";
import { KeyBuilderSS } from '../KeyBuilderSS';
import { SplitsCachePluggable } from './SplitsCachePluggable';
import { SegmentsCachePluggable } from './SegmentsCachePluggable';
import { ImpressionsCachePluggable } from './ImpressionsCachePluggable';
import { EventsCachePluggable } from './EventsCachePluggable';
import { wrapperAdapter, METHODS_TO_PROMISE_WRAP } from './wrapperAdapter';
import { isObject } from '../../utils/lang';
import { validatePrefix } from '../KeyBuilder';
import { CONSUMER_PARTIAL_MODE, STORAGE_PLUGGABLE } from '../../utils/constants';
import { ImpressionsCacheInMemory } from '../inMemory/ImpressionsCacheInMemory';
import { EventsCacheInMemory } from '../inMemory/EventsCacheInMemory';
import { ImpressionCountsCacheInMemory } from '../inMemory/ImpressionCountsCacheInMemory';
var NO_VALID_WRAPPER = 'Expecting pluggable storage `wrapper` in options, but no valid wrapper instance was provided.';
var NO_VALID_WRAPPER_INTERFACE = 'The provided wrapper instance doesnâ€™t follow the expected interface. Check our docs.';
/**
 * Validate pluggable storage factory options.
 *
 * @param options user options
 * @throws Will throw an error if the options are invalid. Example: wrapper is not provided or doesn't have some methods.
 */
function validatePluggableStorageOptions(options) {
    if (!isObject(options) || !isObject(options.wrapper))
        throw new Error(NO_VALID_WRAPPER);
    var wrapper = options.wrapper;
    var missingMethods = METHODS_TO_PROMISE_WRAP.filter(function (method) { return typeof wrapper[method] !== 'function'; });
    if (missingMethods.length)
        throw new Error(NO_VALID_WRAPPER_INTERFACE + " The following methods are missing or invalid: " + missingMethods);
}
// subscription to wrapper connect event in order to emit SDK_READY event
function wrapperConnect(wrapper, onReadyCb) {
    wrapper.connect().then(function () {
        onReadyCb();
    }).catch(function (e) {
        onReadyCb(e || new Error('Error connecting wrapper'));
    });
}
// Async return type in `client.track` method on consumer partial mode
// No need to promisify impressions cache
function promisifyEventsTrack(events) {
    var origTrack = events.track;
    events.track = function () {
        return Promise.resolve(origTrack.apply(this, arguments));
    };
    return events;
}
/**
 * Pluggable storage factory for consumer server-side & client-side SplitFactory.
 */
export function PluggableStorage(options) {
    validatePluggableStorageOptions(options);
    var prefix = validatePrefix(options.prefix);
    function PluggableStorageFactory(_a) {
        var log = _a.log, metadata = _a.metadata, onReadyCb = _a.onReadyCb, mode = _a.mode, eventsQueueSize = _a.eventsQueueSize, impressionsQueueSize = _a.impressionsQueueSize, optimize = _a.optimize;
        var keys = new KeyBuilderSS(prefix, metadata);
        var wrapper = wrapperAdapter(log, options.wrapper);
        var isPartialConsumer = mode === CONSUMER_PARTIAL_MODE;
        // Connects to wrapper and emits SDK_READY event on main client
        wrapperConnect(wrapper, onReadyCb);
        return {
            splits: new SplitsCachePluggable(log, keys, wrapper),
            segments: new SegmentsCachePluggable(log, keys, wrapper),
            impressions: isPartialConsumer ? new ImpressionsCacheInMemory(impressionsQueueSize) : new ImpressionsCachePluggable(log, keys.buildImpressionsKey(), wrapper, metadata),
            impressionCounts: optimize ? new ImpressionCountsCacheInMemory() : undefined,
            events: isPartialConsumer ? promisifyEventsTrack(new EventsCacheInMemory(eventsQueueSize)) : new EventsCachePluggable(log, keys.buildEventsKey(), wrapper, metadata),
            // @TODO add telemetry cache when required
            // Disconnect the underlying storage
            destroy: function () {
                return wrapper.disconnect();
            },
            // emits SDK_READY event on shared clients and returns a reference to the storage
            shared: function (_, onReadyCb) {
                wrapperConnect(wrapper, onReadyCb);
                return __assign(__assign({}, this), { 
                    // no-op destroy, to disconnect the wrapper only when the main client is destroyed
                    destroy: function () { } });
            }
        };
    }
    PluggableStorageFactory.type = STORAGE_PLUGGABLE;
    return PluggableStorageFactory;
}
