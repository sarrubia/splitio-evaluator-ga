"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitApiFactory = void 0;
var splitHttpClient_1 = require("./splitHttpClient");
var objectAssign_1 = require("../utils/lang/objectAssign");
var constants_1 = require("../utils/constants");
var constants_2 = require("../logger/constants");
var noCacheHeaderOptions = { headers: { 'Cache-Control': 'no-cache' } };
function userKeyToQueryParam(userKey) {
    return 'users=' + encodeURIComponent(userKey); // no need to check availability of `encodeURIComponent`, since it is a global highly supported.
}
/**
 * Factory of SplitApi objects, which group the collection of Split HTTP endpoints used by the SDK
 *
 * @param settings validated settings object
 * @param platform object containing environment-specific dependencies
 * @param telemetryTracker telemetry tracker
 */
function splitApiFactory(settings, platform, telemetryTracker) {
    var urls = settings.urls;
    var filterQueryString = settings.sync.__splitFiltersValidation && settings.sync.__splitFiltersValidation.queryString;
    var SplitSDKImpressionsMode = settings.sync.impressionsMode;
    var splitHttpClient = (0, splitHttpClient_1.splitHttpClientFactory)(settings, platform.getFetch);
    return {
        // @TODO throw errors if health check requests fail, to log them in the Synchronizer
        getSdkAPIHealthCheck: function () {
            var url = urls.sdk + "/version";
            return splitHttpClient(url).then(function () { return true; }).catch(function () { return false; });
        },
        getEventsAPIHealthCheck: function () {
            var url = urls.events + "/version";
            return splitHttpClient(url).then(function () { return true; }).catch(function () { return false; });
        },
        fetchAuth: function (userMatchingKeys) {
            var url = urls.auth + "/v2/auth";
            if (userMatchingKeys) { // accounting the possibility that `userMatchingKeys` is undefined (server-side API)
                var queryParams = userMatchingKeys.map(userKeyToQueryParam).join('&');
                if (queryParams) // accounting the possibility that `userKeys` and thus `queryParams` are empty
                    url += '?' + queryParams;
            }
            return splitHttpClient(url, undefined, telemetryTracker.trackHttp(constants_1.TOKEN));
        },
        fetchSplitChanges: function (since, noCache, till) {
            var url = urls.sdk + "/splitChanges?since=" + since + (till ? '&till=' + till : '') + (filterQueryString || '');
            return splitHttpClient(url, noCache ? noCacheHeaderOptions : undefined, telemetryTracker.trackHttp(constants_1.SPLITS))
                .catch(function (err) {
                if (err.statusCode === 414)
                    settings.log.error(constants_2.ERROR_TOO_MANY_SETS);
                throw err;
            });
        },
        fetchSegmentChanges: function (since, segmentName, noCache, till) {
            var url = urls.sdk + "/segmentChanges/" + segmentName + "?since=" + since + (till ? '&till=' + till : '');
            return splitHttpClient(url, noCache ? noCacheHeaderOptions : undefined, telemetryTracker.trackHttp(constants_1.SEGMENT));
        },
        fetchMySegments: function (userMatchingKey, noCache) {
            /**
             * URI encoding of user keys in order to:
             *  - avoid 400 responses (due to URI malformed). E.g.: '/api/mySegments/%'
             *  - avoid 404 responses. E.g.: '/api/mySegments/foo/bar'
             *  - match user keys with special characters. E.g.: 'foo%bar', 'foo/bar'
             */
            var url = urls.sdk + "/mySegments/" + encodeURIComponent(userMatchingKey);
            return splitHttpClient(url, noCache ? noCacheHeaderOptions : undefined, telemetryTracker.trackHttp(constants_1.MY_SEGMENT));
        },
        /**
         * Post events.
         *
         * @param body  Events bulk payload
         * @param headers  Optionals headers to overwrite default ones. For example, it is used in producer mode to overwrite metadata headers.
         */
        postEventsBulk: function (body, headers) {
            var url = urls.events + "/events/bulk";
            return splitHttpClient(url, { method: 'POST', body: body, headers: headers }, telemetryTracker.trackHttp(constants_1.EVENTS));
        },
        /**
         * Post impressions.
         *
         * @param body  Impressions bulk payload
         * @param headers  Optionals headers to overwrite default ones. For example, it is used in producer mode to overwrite metadata headers.
         */
        postTestImpressionsBulk: function (body, headers) {
            var url = urls.events + "/testImpressions/bulk";
            return splitHttpClient(url, {
                // Adding extra headers to send impressions in OPTIMIZED or DEBUG modes.
                method: 'POST',
                body: body,
                headers: (0, objectAssign_1.objectAssign)({ SplitSDKImpressionsMode: SplitSDKImpressionsMode }, headers)
            }, telemetryTracker.trackHttp(constants_1.IMPRESSIONS));
        },
        /**
         * Post impressions counts.
         *
         * @param body  Impressions counts payload
         * @param headers  Optionals headers to overwrite default ones. For example, it is used in producer mode to overwrite metadata headers.
         */
        postTestImpressionsCount: function (body, headers) {
            var url = urls.events + "/testImpressions/count";
            return splitHttpClient(url, { method: 'POST', body: body, headers: headers }, telemetryTracker.trackHttp(constants_1.IMPRESSIONS_COUNT));
        },
        /**
         * Post unique keys for client side.
         *
         * @param body  unique keys payload
         * @param headers  Optionals headers to overwrite default ones. For example, it is used in producer mode to overwrite metadata headers.
         */
        postUniqueKeysBulkCs: function (body, headers) {
            var url = urls.telemetry + "/v1/keys/cs";
            return splitHttpClient(url, { method: 'POST', body: body, headers: headers }, telemetryTracker.trackHttp(constants_1.TELEMETRY));
        },
        /**
         * Post unique keys for server side.
         *
         * @param body  unique keys payload
         * @param headers  Optionals headers to overwrite default ones. For example, it is used in producer mode to overwrite metadata headers.
         */
        postUniqueKeysBulkSs: function (body, headers) {
            var url = urls.telemetry + "/v1/keys/ss";
            return splitHttpClient(url, { method: 'POST', body: body, headers: headers }, telemetryTracker.trackHttp(constants_1.TELEMETRY));
        },
        postMetricsConfig: function (body, headers) {
            var url = urls.telemetry + "/v1/metrics/config";
            return splitHttpClient(url, { method: 'POST', body: body, headers: headers }, telemetryTracker.trackHttp(constants_1.TELEMETRY), true);
        },
        postMetricsUsage: function (body, headers) {
            var url = urls.telemetry + "/v1/metrics/usage";
            return splitHttpClient(url, { method: 'POST', body: body, headers: headers }, telemetryTracker.trackHttp(constants_1.TELEMETRY), true);
        }
    };
}
exports.splitApiFactory = splitApiFactory;
