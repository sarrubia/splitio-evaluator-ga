"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventsCacheInRedis = void 0;
var constants_1 = require("./constants");
var EventsCacheInRedis = /** @class */ (function () {
    function EventsCacheInRedis(log, key, redis, metadata) {
        this.log = log;
        this.key = key;
        this.redis = redis;
        this.metadata = metadata;
    }
    /**
     * Add a new event object into the queue.
     * Unlike `impressions::track`, result promise is never rejected.
     */
    EventsCacheInRedis.prototype.track = function (eventData) {
        var _this = this;
        return this.redis.rpush(this.key, this._toJSON(eventData))
            // We use boolean values to signal successful queueing
            .then(function () { return true; })
            .catch(function (err) {
            _this.log.error(constants_1.LOG_PREFIX + "Error adding event to queue: " + err + ".");
            return false;
        });
    };
    /**
     * Generates the JSON as we'll store it on Redis.
     */
    EventsCacheInRedis.prototype._toJSON = function (eventData) {
        return JSON.stringify({
            m: this.metadata,
            e: eventData
        });
    };
    EventsCacheInRedis.prototype.count = function () {
        return this.redis.llen(this.key).catch(function () { return 0; });
    };
    EventsCacheInRedis.prototype.drop = function (count) {
        if (!count)
            return this.redis.del(this.key);
        return this.redis.ltrim(this.key, count, -1);
    };
    /**
     * Pop the given number of events from the storage.
     * The returned promise rejects if the redis operation fails.
     *
     * NOTE: this method doesn't take into account MAX_EVENT_SIZE or MAX_QUEUE_BYTE_SIZE limits.
     * It is the submitter responsability to handle that.
     */
    EventsCacheInRedis.prototype.popNWithMetadata = function (count) {
        var _this = this;
        return this.redis.lrange(this.key, 0, count - 1).then(function (items) {
            return _this.redis.ltrim(_this.key, items.length, -1).then(function () {
                return items.map(function (item) { return JSON.parse(item); });
            });
        });
    };
    return EventsCacheInRedis;
}());
exports.EventsCacheInRedis = EventsCacheInRedis;
