"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InLocalStorage = void 0;
var ImpressionsCacheInMemory_1 = require("../inMemory/ImpressionsCacheInMemory");
var ImpressionCountsCacheInMemory_1 = require("../inMemory/ImpressionCountsCacheInMemory");
var EventsCacheInMemory_1 = require("../inMemory/EventsCacheInMemory");
var KeyBuilder_1 = require("../KeyBuilder");
var KeyBuilderCS_1 = require("../KeyBuilderCS");
var isLocalStorageAvailable_1 = require("../../utils/env/isLocalStorageAvailable");
var SplitsCacheInLocal_1 = require("./SplitsCacheInLocal");
var MySegmentsCacheInLocal_1 = require("./MySegmentsCacheInLocal");
var MySegmentsCacheInMemory_1 = require("../inMemory/MySegmentsCacheInMemory");
var SplitsCacheInMemory_1 = require("../inMemory/SplitsCacheInMemory");
var browser_1 = require("../../utils/constants/browser");
var InMemoryStorageCS_1 = require("../inMemory/InMemoryStorageCS");
var constants_1 = require("./constants");
var constants_2 = require("../../utils/constants");
/**
 * InLocal storage factory for standalone client-side SplitFactory
 */
function InLocalStorage(options) {
    if (options === void 0) { options = {}; }
    var prefix = (0, KeyBuilder_1.validatePrefix)(options.prefix);
    function InLocalStorageCSFactory(params) {
        // Fallback to InMemoryStorage if LocalStorage API is not available
        if (!(0, isLocalStorageAvailable_1.isLocalStorageAvailable)()) {
            params.log.warn(constants_1.LOG_PREFIX + 'LocalStorage API is unavailable. Fallbacking into default MEMORY storage');
            return (0, InMemoryStorageCS_1.InMemoryStorageCSFactory)(params);
        }
        var log = params.log;
        var keys = new KeyBuilderCS_1.KeyBuilderCS(prefix, params.matchingKey);
        var expirationTimestamp = Date.now() - browser_1.DEFAULT_CACHE_EXPIRATION_IN_MILLIS;
        return {
            splits: new SplitsCacheInLocal_1.SplitsCacheInLocal(log, keys, expirationTimestamp, params.splitFiltersValidation),
            segments: new MySegmentsCacheInLocal_1.MySegmentsCacheInLocal(log, keys),
            impressions: new ImpressionsCacheInMemory_1.ImpressionsCacheInMemory(params.impressionsQueueSize),
            impressionCounts: params.optimize ? new ImpressionCountsCacheInMemory_1.ImpressionCountsCacheInMemory() : undefined,
            events: new EventsCacheInMemory_1.EventsCacheInMemory(params.eventsQueueSize),
            destroy: function () {
                this.splits = new SplitsCacheInMemory_1.SplitsCacheInMemory();
                this.segments = new MySegmentsCacheInMemory_1.MySegmentsCacheInMemory();
                this.impressions.clear();
                this.impressionCounts && this.impressionCounts.clear();
                this.events.clear();
            },
            // When using shared instanciation with MEMORY we reuse everything but segments (they are customer per key).
            shared: function (matchingKey) {
                var childKeysBuilder = new KeyBuilderCS_1.KeyBuilderCS(prefix, matchingKey);
                return {
                    splits: this.splits,
                    segments: new MySegmentsCacheInLocal_1.MySegmentsCacheInLocal(log, childKeysBuilder),
                    impressions: this.impressions,
                    impressionCounts: this.impressionCounts,
                    events: this.events,
                    destroy: function () {
                        this.splits = new SplitsCacheInMemory_1.SplitsCacheInMemory();
                        this.segments = new MySegmentsCacheInMemory_1.MySegmentsCacheInMemory();
                    }
                };
            },
        };
    }
    InLocalStorageCSFactory.type = constants_2.STORAGE_LOCALSTORAGE;
    return InLocalStorageCSFactory;
}
exports.InLocalStorage = InLocalStorage;
