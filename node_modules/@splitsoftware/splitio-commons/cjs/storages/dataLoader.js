"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dataLoaderFactory = void 0;
var browser_1 = require("../utils/constants/browser");
/**
 * Factory of client-side storage loader
 *
 * @param preloadedData validated data following the format proposed in https://github.com/godaddy/split-javascript-data-loader
 * and extended with a `mySegmentsData` property.
 * @returns function to preload the storage
 */
function dataLoaderFactory(preloadedData) {
    /**
     * Storage-agnostic adaptation of `loadDataIntoLocalStorage` function
     * (https://github.com/godaddy/split-javascript-data-loader/blob/master/src/load-data.js)
     *
     * @param storage object containing `splits` and `segments` cache (client-side variant)
     * @param userId user key string of the provided MySegmentsCache
     *
     * @TODO extend to support SegmentsCache (server-side variant) by making `userId` optional and adding the corresponding logic.
     * @TODO extend to load data on shared mySegments storages. Be specific when emitting SDK_READY_FROM_CACHE on shared clients. Maybe the serializer should provide the `useSegments` flag.
     */
    return function loadData(storage, userId) {
        // Do not load data if current preloadedData is empty
        if (Object.keys(preloadedData).length === 0)
            return;
        var _a = preloadedData.lastUpdated, lastUpdated = _a === void 0 ? -1 : _a, _b = preloadedData.segmentsData, segmentsData = _b === void 0 ? {} : _b, _c = preloadedData.since, since = _c === void 0 ? -1 : _c, _d = preloadedData.splitsData, splitsData = _d === void 0 ? {} : _d;
        var storedSince = storage.splits.getChangeNumber();
        var expirationTimestamp = Date.now() - browser_1.DEFAULT_CACHE_EXPIRATION_IN_MILLIS;
        // Do not load data if current localStorage data is more recent,
        // or if its `lastUpdated` timestamp is older than the given `expirationTimestamp`,
        if (storedSince > since || lastUpdated < expirationTimestamp)
            return;
        // cleaning up the localStorage data, since some cached splits might need be part of the preloaded data
        storage.splits.clear();
        storage.splits.setChangeNumber(since);
        // splitsData in an object where the property is the split name and the pertaining value is a stringified json of its data
        storage.splits.addSplits(Object.keys(splitsData).map(function (splitName) { return JSON.parse(splitsData[splitName]); }));
        // add mySegments data
        var mySegmentsData = preloadedData.mySegmentsData && preloadedData.mySegmentsData[userId];
        if (!mySegmentsData) {
            // segmentsData in an object where the property is the segment name and the pertaining value is a stringified object that contains the `added` array of userIds
            mySegmentsData = Object.keys(segmentsData).filter(function (segmentName) {
                var userIds = JSON.parse(segmentsData[segmentName]).added;
                return Array.isArray(userIds) && userIds.indexOf(userId) > -1;
            });
        }
        storage.segments.resetSegments(mySegmentsData);
    };
}
exports.dataLoaderFactory = dataLoaderFactory;
