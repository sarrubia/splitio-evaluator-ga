"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eventTrackerFactory = void 0;
var objectAssign_1 = require("../utils/lang/objectAssign");
var thenable_1 = require("../utils/promise/thenable");
var constants_1 = require("../logger/constants");
var constants_2 = require("../utils/constants");
var mode_1 = require("../utils/settingsValidation/mode");
/**
 * Event tracker stores events in cache and pass them to the integrations manager if provided.
 *
 * @param eventsCache cache to save events
 * @param integrationsManager optional event handler used for integrations
 */
function eventTrackerFactory(settings, eventsCache, integrationsManager, telemetryCache) {
    var log = settings.log, mode = settings.mode;
    var isAsync = (0, mode_1.isConsumerMode)(mode);
    function queueEventsCallback(eventData, tracked) {
        var eventTypeId = eventData.eventTypeId, trafficTypeName = eventData.trafficTypeName, key = eventData.key, value = eventData.value, timestamp = eventData.timestamp, properties = eventData.properties;
        // Logging every prop would be too much.
        var msg = "event of type \"" + eventTypeId + "\" for traffic type \"" + trafficTypeName + "\". Key: " + key + ". Value: " + value + ". Timestamp: " + timestamp + ". " + (properties ? 'With properties.' : 'With no properties.');
        if (tracked) {
            log.info(constants_1.EVENTS_TRACKER_SUCCESS, [msg]);
            if (integrationsManager) {
                // Wrap in a timeout because we don't want it to be blocking.
                setTimeout(function () {
                    // copy of event, to avoid unexpected behaviour if modified by integrations
                    var eventDataCopy = (0, objectAssign_1.objectAssign)({}, eventData);
                    if (properties)
                        eventDataCopy.properties = (0, objectAssign_1.objectAssign)({}, properties);
                    // integrationsManager does not throw errors (they are internally handled by each integration module)
                    integrationsManager.handleEvent(eventDataCopy);
                }, 0);
            }
        }
        else {
            log.error(constants_1.ERROR_EVENTS_TRACKER, [msg]);
        }
        return tracked;
    }
    return {
        track: function (eventData, size) {
            if (settings.userConsent === constants_2.CONSENT_DECLINED) {
                return isAsync ? Promise.resolve(false) : false;
            }
            var tracked = eventsCache.track(eventData, size);
            if ((0, thenable_1.thenable)(tracked)) {
                return tracked.then(queueEventsCallback.bind(null, eventData));
            }
            else {
                // Record when eventsCache is sync only (standalone mode)
                // @TODO we are not dropping events on full queue yet, so `tracked` is always true ATM
                if (telemetryCache)
                    telemetryCache.recordEventStats(tracked ? constants_2.QUEUED : constants_2.DROPPED, 1);
                return queueEventsCallback(eventData, tracked);
            }
        }
    };
}
exports.eventTrackerFactory = eventTrackerFactory;
